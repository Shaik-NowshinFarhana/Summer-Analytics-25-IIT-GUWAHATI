# -*- coding: utf-8 -*-
"""Capstone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m9I-ou_3IUUuLeV0lQUj2UICszItOMrG
"""

import pandas as pd
import numpy as np

# Step 1: Load and Explore Dataset
df = pd.read_csv('dataset.csv')
print("Shape of the dataset:", df.shape)
print("\nColumn names:\n", df.columns.tolist())
print("\nData Types:\n", df.dtypes)
print("\nFirst few rows:")
display(df.head())

# Check for missing values
print("\nMissing values per column:")
print(df.isnull().sum())

"""***Model 1: Baseline Linear Model


           A simple model where the next price is a function of the previous price and current
           occupancy:
â€¢ Linear price increase as occupancy increases
â€¢ Acts as a reference point

Example:

`Price(t+1) = Price(t) + Î± Â·(Occupancy/Capacity)***`
"""

# Step 2: Feature Engineering for Model 1

# Combine date and time into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'], format='%d-%m-%Y %H:%M:%S')

# Sort by parking lot and timestamp
df.sort_values(by=['SystemCodeNumber', 'Timestamp'], inplace=True)

# Calculate occupancy rate
df['OccupancyRate'] = df['Occupancy'] / df['Capacity']

# Initialize base price
base_price = 10
alpha = 5  # Price sensitivity to occupancy rate

# Initialize a price column with base price
df['Price_Model1'] = base_price

# Compute price over time for each parking lot
for lot in df['SystemCodeNumber'].unique():
    lot_indices = df[df['SystemCodeNumber'] == lot].index
    for i in range(1, len(lot_indices)):
        prev_idx = lot_indices[i-1]
        curr_idx = lot_indices[i]
        prev_price = df.loc[prev_idx, 'Price_Model1']
        occupancy_rate = df.loc[curr_idx, 'OccupancyRate']

        new_price = prev_price + alpha * occupancy_rate
        df.loc[curr_idx, 'Price_Model1'] = new_price

# Preview results
df[['SystemCodeNumber', 'Timestamp', 'OccupancyRate', 'Price_Model1']].head(10)

import matplotlib.pyplot as plt

# Choose one parking lot (e.g., first unique one)
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot]

# Plot
plt.figure(figsize=(12, 5))
plt.plot(sample_df['Timestamp'], sample_df['Price_Model1'], marker='o', linestyle='-')
plt.title(f'Price Over Time - Model 1 (Linear) - {sample_lot}')
plt.xlabel('Time')
plt.ylabel('Price ($)')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

print("Price stats for Model 1:")
print("Min Price: $", round(df['Price_Model1'].min(), 2))
print("Max Price: $", round(df['Price_Model1'].max(), 2))
print("Average Price: $", round(df['Price_Model1'].mean(), 2))

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource
from bokeh.layouts import layout
from bokeh.models import HoverTool

# Enable inline Bokeh output
output_notebook()

# Select a sample lot (e.g., the first unique one)
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()

# Prepare data source
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")
source = ColumnDataSource(sample_df)

# Create Bokeh figure
p = figure(x_axis_type="datetime", title=f"Model 1: Price Over Time for {sample_lot}",
           width=900, height=400, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Plot line
p.line(x='Timestamp', y='Price_Model1', source=source, line_width=2, color='navy', legend_label='Price ($)')
p.circle(x='Timestamp', y='Price_Model1', source=source, size=4, color='navy', alpha=0.6)

# Hover tool
hover = p.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model1{$0.00}"),
    ("Occupancy Rate", "@OccupancyRate{0.00}")
]

# Aesthetic settings
p.xaxis.axis_label = "Time"
p.yaxis.axis_label = "Price ($)"
p.legend.location = "top_left"
p.grid.grid_line_alpha = 0.3

# Show plot
show(p)

"""***Model 2: Demand-Based Price Function

A more advanced model where you:
â€¢ Construct a mathematical demand function using key features:

```
â€“ Occupancy rate
â€“ Queue length
â€“ Traffic level
â€“ Special day
â€“ Vehicle type
```
![Screenshot 2025-07-07 094812.png](data:image/png;base64,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)


"""

# Map traffic levels to numeric
traffic_map = {'low': 1, 'medium': 2, 'high': 3}
df['TrafficLevelNum'] = df['TrafficConditionNearby'].map(traffic_map)

# Assign numeric weights to vehicle types
vehicle_weights = {'bike': 0.5, 'car': 1.0, 'truck': 1.5}
df['VehicleWeight'] = df['VehicleType'].map(vehicle_weights)

"""***

```
define coefficients:

Î± = 0.5 (occupancy rate)

Î² = 0.3 (queue length)

Î³ = 0.2 (traffic penalty)

Î´ = 0.5 (special day bonus)

Îµ = 0.7 (vehicle type influence)
```


***
"""

# Define coefficients
a, b, c, d, e = 0.5, 0.3, 0.2, 0.5, 0.7

# Raw demand calculation
df['DemandRaw'] = (
    a * df['OccupancyRate'] +
    b * df['QueueLength'] -
    c * df['TrafficLevelNum'] +
    d * df['IsSpecialDay'] +
    e * df['VehicleWeight']
)

"""

```
Normalize Demand & Set Price
```

"""

# Normalize demand to [0, 1]
dmin, dmax = df['DemandRaw'].min(), df['DemandRaw'].max()
df['DemandNorm'] = (df['DemandRaw'] - dmin) / (dmax - dmin)

# Define lambda for price sensitivity
lambda_val = 1.0

# Calculate demand-based price (bounded)
df['Price_Model2'] = 10 * (1 + lambda_val * df['DemandNorm'])
df['Price_Model2'] = df['Price_Model2'].clip(lower=5, upper=20)

"""***`Interactive Bokeh Plot for Model 2`

    plot Price_Model2 over time for the same parking lot
    

***
"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool

# Enable Bokeh in notebook
output_notebook()

# Filter the same parking lot as before
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()

# Prepare timestamp string for hover
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Prepare data source
source = ColumnDataSource(sample_df)

# Create Bokeh plot
p2 = figure(x_axis_type="datetime", title=f"Model 2: Demand-Based Price Over Time for {sample_lot}",
           width=900, height=400, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Plot line and circles
p2.line(x='Timestamp', y='Price_Model2', source=source, line_width=2, color='green', legend_label='Price ($)')
p2.circle(x='Timestamp', y='Price_Model2', source=source, size=5, color='green', alpha=0.6)

# Hover tool
hover2 = p2.select(dict(type=HoverTool))
hover2.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model2{$0.00}"),
    ("Demand (normalized)", "@DemandNorm{0.00}")
]

# Axis labels and styling
p2.xaxis.axis_label = "Time"
p2.yaxis.axis_label = "Price ($)"
p2.legend.location = "top_left"
p2.grid.grid_line_alpha = 0.3

# Show the plot
show(p2)

"""***
```
Model 3 â€“ Competitive Pricing Logic

```
```
Extended Model 2 by adding location intelligence:

Nearby parking lots (within 1 km)

Their current price

Adjust price up/down based on competition & occupancy


```

```
** Competitive Logic

If lot is full and nearby lots are cheaper â†’ suggest rerouting / reduce price

If nearby lots are expensive or full â†’ increase your price
**
```

```
 Haversine Function to Compute Proximity
"""

# Haversine distance in km
def haversine(lat1, lon1, lat2, lon2):
    R = 6371  # Earth radius (km)
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)

    a = np.sin(d_phi/2)**2 + np.cos(phi1)*np.cos(phi2)*np.sin(d_lambda/2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

"""

```
Compute Nearby Lot Prices at Each Time

"""

# Copy model 2 price
df['Price_Model3'] = df['Price_Model2']  # initialize from demand-based price
df['SuggestReroute'] = 0  # 1 if we suggest rerouting

# Group by time
for timestamp in df['Timestamp'].unique():
    snapshot = df[df['Timestamp'] == timestamp].copy()  # <--- Fix here

    for idx, row in snapshot.iterrows():
        lot_lat, lot_lon = row['Latitude'], row['Longitude']
        lot_price = row['Price_Model2']
        lot_occ = row['Occupancy']
        lot_cap = row['Capacity']

        snapshot['Distance'] = snapshot.apply(
            lambda r: haversine(lot_lat, lot_lon, r['Latitude'], r['Longitude']), axis=1)

        nearby = snapshot[(snapshot['SystemCodeNumber'] != row['SystemCodeNumber']) & (snapshot['Distance'] < 1)]

        if len(nearby) > 0:
            nearby_prices = nearby['Price_Model2']
            nearby_occ_rates = nearby['Occupancy'] / nearby['Capacity']

            avg_nearby_price = nearby_prices.mean()
            avg_nearby_occ = nearby_occ_rates.mean()

            # Pricing logic
            if (lot_occ / lot_cap) >= 0.9 and avg_nearby_price < lot_price:
                df.loc[idx, 'Price_Model3'] = max(5, lot_price - 2)
                df.loc[idx, 'SuggestReroute'] = 1
            elif avg_nearby_occ > 0.9 and avg_nearby_price > lot_price:
                df.loc[idx, 'Price_Model3'] = min(20, lot_price + 2)

"""

```
 Bokeh Plot for Model 3 with Rerouting Highlights

Plot price over time

Using circle color for rerouting suggestion:

ðŸ”´ Red â†’ Reroute suggested

ðŸŸ¢ Green â†’ No reroute
```

"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.transform import factor_cmap

output_notebook()

# Refresh sample lot
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Label rerouting as "Yes"/"No"
sample_df['Reroute'] = sample_df['SuggestReroute'].apply(lambda x: "Yes" if x == 1 else "No")

# Create data source
source = ColumnDataSource(sample_df)

# Color map: red if reroute suggested, green otherwise
reroute_colors = factor_cmap('Reroute',
                             palette=['green', 'red'],
                             factors=['No', 'Yes'])

# Create figure
p3 = figure(x_axis_type="datetime", title=f"Model 3: Competitive Price + Reroute Suggestion for {sample_lot}",
            width=950, height=450, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Line for base price evolution
p3.line(x='Timestamp', y='Price_Model3', source=source, line_width=2, color='black', legend_label='Price ($)')

# Colored circle markers for reroute suggestion
p3.circle(x='Timestamp', y='Price_Model3', source=source, size=8,
          fill_color=reroute_colors, line_color='black', alpha=0.8, legend_field='Reroute')

# Hover tool
hover = p3.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model3{$0.00}"),
    ("Suggest Reroute", "@Reroute"),
    ("Occupancy Rate", "@OccupancyRate{0.00}"),
]

# Styling
p3.xaxis.axis_label = "Time"
p3.yaxis.axis_label = "Price ($)"
p3.legend.location = "top_left"
p3.grid.grid_line_alpha = 0.3

# Show plot
show(p3)

"""

```
 Comparison Plot: Model 2 vs Model 3 Pricing Over Time:
```

"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool

output_notebook()

# Filter same parking lot
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Create source
source = ColumnDataSource(sample_df)

# Create plot
p_compare = figure(x_axis_type="datetime", title=f"Model 2 vs Model 3: Price Comparison for {sample_lot}",
                   width=950, height=450, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Model 2 line (Demand-Based)
p_compare.line(x='Timestamp', y='Price_Model2', source=source, line_width=2,
               color='blue', legend_label='Model 2: Demand-Based')

# Model 3 line (Competitive)
p_compare.line(x='Timestamp', y='Price_Model3', source=source, line_width=2,
               color='red', legend_label='Model 3: Competitive')

# Add dots for better visibility
p_compare.circle(x='Timestamp', y='Price_Model2', source=source, size=5,
                 color='blue', alpha=0.6)
p_compare.circle(x='Timestamp', y='Price_Model3', source=source, size=5,
                 color='red', alpha=0.6)

# Hover tool
hover = p_compare.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price M2", "@Price_Model2{$0.00}"),
    ("Price M3", "@Price_Model3{$0.00}"),
    ("Occupancy", "@Occupancy"),
    ("Reroute", "@SuggestReroute"),
]

# Styling
p_compare.xaxis.axis_label = "Time"
p_compare.yaxis.axis_label = "Price ($)"
p_compare.legend.location = "top_left"
p_compare.grid.grid_line_alpha = 0.3

# Show
show(p_compare)

"""

```
Blue line: Demand-based pricing

Red line: Competitive-aware adjustments

Dips in red line when reroute is suggested

Red spikes where neighboring lots are full


```

"""

!pip install pathway

@pw.udf(return_type=float)
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)
    a = np.sin(d_phi / 2)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(d_lambda / 2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

import pandas as pd
import pathway as pw
from pathway.internals.dtype import DATE_TIME_NAIVE
import numpy as np

# --- Step 1: Preprocess Data ----------------------------------
df['Timestamp'] = pd.to_datetime(
    df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
    format='%d-%m-%Y %H:%M:%S'
)
df['ID'] = df['ID'].astype(str)

# --- Step 2: Schema -------------------------------------------
class ParkingLot(pw.Schema):
    ID: str
    SystemCodeNumber: str
    Capacity: int
    Latitude: float
    Longitude: float
    Occupancy: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    Timestamp: DATE_TIME_NAIVE
    Price_Model2: float

# --- Step 3: ConnectorSubject ---------------------------------
class ParkingSubject(pw.io.python.ConnectorSubject):
    def __init__(self, df):
        super().__init__()
        self.df = df.sort_values('Timestamp')
    def run(self):
        for _, row in self.df.iterrows():
            self.next(
                ID=str(row['ID']),
                SystemCodeNumber=row['SystemCodeNumber'],
                Capacity=int(row['Capacity']),
                Latitude=float(row['Latitude']),
                Longitude=float(row['Longitude']),
                Occupancy=int(row['Occupancy']),
                VehicleType=row['VehicleType'],
                TrafficConditionNearby=row['TrafficConditionNearby'],
                QueueLength=int(row['QueueLength']),
                IsSpecialDay=int(row['IsSpecialDay']),
                Timestamp=row['Timestamp'],
                Price_Model2=float(row['Price_Model2'])
            )
        self.close()

# --- Step 4: Read stream --------------------------------------
stream = pw.io.python.read(ParkingSubject(df), schema=ParkingLot)

# --- Step 5: Rename columns in right stream before join -------
stream_reduced = stream.select(
    ID_R=stream.ID,
    Timestamp_R=stream.Timestamp,
    Latitude_R=stream.Latitude,
    Longitude_R=stream.Longitude,
    Capacity_R=stream.Capacity,
    Occupancy_R=stream.Occupancy,
    Price_Model2_R=stream.Price_Model2
)

# --- Step 6: Join streams -------------------------------------
joined = pw.join(stream, stream_reduced)

# --- Step 7: Haversine distance function ----------------------
@pw.udf(return_type=float)
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)
    a = np.sin(d_phi / 2)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(d_lambda / 2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

# --- Step 8: Filter nearby competitors ------------------------
nearby = joined.filter(
    (joined["Timestamp"] == joined["Timestamp_R"]) &
    (haversine(
        joined["Latitude"], joined["Longitude"],
        joined["Latitude_R"], joined["Longitude_R"]
    ) < 1)
)

# --- Step 9: Convert join to table before group_by ------------

# --- Step 10: Aggregate competitor stats ----------------------
# âœ… Step: Select into a real table
selected = nearby.select(
    ID=joined["ID"],
    Timestamp=joined["Timestamp"],
    SystemCodeNumber=joined["SystemCodeNumber"],
    Price_Model2=joined["Price_Model2"],
    Occupancy=joined["Occupancy"],
    Capacity=joined["Capacity"],
    Price_Model2_R=joined["Price_Model2_R"],
    Occupancy_R=joined["Occupancy_R"],
    Capacity_R=joined["Capacity_R"]
)

# ðŸ§  View what columns exist (for debugging)
print("Columns:", selected.schema)

# # âœ… Step: Use .group_by correctly
agg = selected.group_by("ID").reduce(
    ID=_.ID,
    Time=_.Timestamp,
    Lot=_.SystemCodeNumber,
    SelfPrice=_.Price_Model2,
    SelfOccRate=_.Occupancy / _.Capacity,
    AvgCompPrice=pw.reducers.mean(_.Price_Model2_R),
    AvgCompOccRate=pw.reducers.mean(_.Occupancy_R / _.Capacity_R)
)


# # --- Step 11: Model 3 pricing logic ---------------------------
@pw.udf
def adjust_price(self_price, self_occ, comp_price, comp_occ):
    if self_occ >= 0.9 and comp_price < self_price:
        return max(5, self_price - 2), 1  # Suggest reroute
    elif comp_occ > 0.9 and comp_price > self_price:
        return min(20, self_price + 2), 0  # Increase price
    return self_price, 0  # No change

# --- Step 12: Final output ------------------------------------
final = agg.select(
    ID=agg.ID,
    Lot=agg.Lot,
    Time=agg.Time,
    Price_Model3_and_Reroute=adjust_price(
        agg.SelfPrice,
        agg.SelfOccRate,
        agg.AvgCompPrice,
        agg.AvgCompOccRate
    )
).select(
    ID=_.ID,
    Lot=_.Lot,
    Time=_.Time,
    Price_Model3=_.Price_Model3_and_Reroute[0],
    Reroute=_.Price_Model3_and_Reroute[1]
)

# --- Step 13: Output to console -------------------------------
pw.io.jsonlines.write(final, "#")
pw.run()

import pandas as pd
from bokeh.plotting import figure, show, output_file
from bokeh.models import ColumnDataSource, HoverTool

data = {
    'Time': pd.date_range(start='2025-07-07 08:00:00', periods=10, freq='5min'),
    'Price_Model3': [10, 11, 12, 10, 14, 13, 15, 10, 12, 11],
    'Reroute': [0, 0, 1, 0, 1, 0, 0, 1, 0, 0]
}


df_vis = pd.DataFrame(data)
df_vis['Color'] = df_vis['Reroute'].map({0: 'green', 1: 'red'})

source = ColumnDataSource(data=df_vis.to_dict(orient='list'))


p = figure(
    title="ðŸš— Model 3: Dynamic Parking Price & Reroute Suggestions",
    x_axis_type='datetime',
    x_axis_label='Time',
    y_axis_label='Price (â‚¹)',
    width=850,
    height=400,
    background_fill_color="#f9f9f9"
)


p.circle(
    x='Time', y='Price_Model3',
    size=10, color='Color',
    source=source,
    legend_field='Reroute'
)


hover = HoverTool(tooltips=[
    ("Time", "@Time{%F %T}"),
    ("Price", "@Price_Model3"),
    ("Reroute", "@Reroute")
], formatters={'@Time': 'datetime'})

p.add_tools(hover)

p.legend.title = "Reroute Suggested (1 = Yes)"
p.legend.location = "top_left"

output_file("model3_pricing.html", title="Model 3 Dynamic Pricing")
show(p)

"""# Parking Price Prediction Report

This report details the process of developing and comparing three different models for predicting parking prices based on various factors, as implemented in the provided code.

## Data Loading and Exploration

The first step involves loading the dataset and understanding its structure and content.
"""

import pandas as pd
import numpy as np

"""This code imports the necessary libraries, `pandas` for data manipulation and `numpy` for numerical operations."""

# Step 1: Load and Explore Dataset
df = pd.read_csv('dataset.csv')
print("Shape of the dataset:", df.shape)
print("\nColumn names:\n", df.columns.tolist())
print("\nData Types:\n", df.dtypes)
print("\nFirst few rows:")
display(df.head())

"""This cell loads the `dataset.csv` file into a pandas DataFrame called `df`. It then prints the shape of the DataFrame (number of rows and columns), the list of column names, the data types of each column, and displays the first few rows of the DataFrame using `display()`. This provides an initial overview of the data."""

# Check for missing values
print("\nMissing values per column:")
print(df.isnull().sum())

"""This code checks for missing values in each column of the DataFrame and prints the count of missing values per column. This helps in identifying if any data cleaning is required.

## Model 1: Baseline Linear Model

This section implements a simple linear model as a baseline for comparison.

***Model 1: Baseline Linear Model

           A simple model where the next price is a function of the previous price and current
           occupancy:
â€¢ Linear price increase as occupancy increases
â€¢ Acts as a reference point

Example:

`Price(t+1) = Price(t) + Î± Â·(Occupancy/Capacity)***`

This markdown cell describes the concept of the baseline linear model, which is based on the previous price and the occupancy rate.
"""

# Step 2: Feature Engineering for Model 1

# Combine date and time into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'], format='%d-%m-%Y %H:%M:%S')

# Sort by parking lot and timestamp
df.sort_values(by=['SystemCodeNumber', 'Timestamp'], inplace=True)

# Calculate occupancy rate
df['OccupancyRate'] = df['Occupancy'] / df['Capacity']

# Initialize base price
base_price = 10
alpha = 5  # Price sensitivity to occupancy rate

# Initialize a price column with base price
df['Price_Model1'] = base_price

# Compute price over time for each parking lot
for lot in df['SystemCodeNumber'].unique():
    lot_indices = df[df['SystemCodeNumber'] == lot].index
    for i in range(1, len(lot_indices)):
        prev_idx = lot_indices[i-1]
        curr_idx = lot_indices[i]
        prev_price = df.loc[prev_idx, 'Price_Model1']
        occupancy_rate = df.loc[curr_idx, 'OccupancyRate']

        new_price = prev_price + alpha * occupancy_rate
        df.loc[curr_idx, 'Price_Model1'] = new_price

# Preview results
df[['SystemCodeNumber', 'Timestamp', 'OccupancyRate', 'Price_Model1']].head(10)

"""This code cell performs feature engineering for Model 1. It combines the date and time columns into a single `Timestamp` column, sorts the data by parking lot and timestamp, and calculates the `OccupancyRate`. It then initializes a `Price_Model1` column with a base price and iteratively calculates the price for each parking lot based on the previous price and the current occupancy rate, using the defined `alpha` coefficient. Finally, it displays the first 10 rows of the relevant columns."""

import matplotlib.pyplot as plt

# Choose one parking lot (e.g., first unique one)
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot]

# Plot
plt.figure(figsize=(12, 5))
plt.plot(sample_df['Timestamp'], sample_df['Price_Model1'], marker='o', linestyle='-')
plt.title(f'Price Over Time - Model 1 (Linear) - {sample_lot}')
plt.xlabel('Time')
plt.ylabel('Price ($)')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""This code uses `matplotlib` to plot the `Price_Model1` over time for a single sample parking lot. It visualizes how the price changes based on the simple linear model."""

print("Price stats for Model 1:")
print("Min Price: $", round(df['Price_Model1'].min(), 2))
print("Max Price: $", round(df['Price_Model1'].max(), 2))
print("Average Price: $", round(df['Price_Model1'].mean(), 2))

"""This cell calculates and prints the minimum, maximum, and average price predicted by Model 1 across all parking lots."""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource
from bokeh.layouts import layout
from bokeh.models import HoverTool

# Enable inline Bokeh output
output_notebook()

# Select a sample lot (e.g., the first unique one)
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()

# Prepare data source
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")
source = ColumnDataSource(sample_df)

# Create Bokeh figure
p = figure(x_axis_type="datetime", title=f"Model 1: Price Over Time for {sample_lot}",
           width=900, height=400, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Plot line
p.line(x='Timestamp', y='Price_Model1', source=source, line_width=2, color='navy', legend_label='Price ($)')
p.circle(x='Timestamp', y='Price_Model1', source=source, size=4, color='navy', alpha=0.6)

# Hover tool
hover = p.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model1{$0.00}"),
    ("Occupancy Rate", "@OccupancyRate{0.00}")
]

# Aesthetic settings
p.xaxis.axis_label = "Time"
p.yaxis.axis_label = "Price ($)"
p.legend.location = "top_left"
p.grid.grid_line_alpha = 0.3

# Show plot
show(p)

"""This code uses the `bokeh` library to create an interactive plot of Model 1's price over time for a sample parking lot. It includes hover tools to display details when hovering over data points.

## Model 2: Demand-Based Price Function

This section implements a more complex model that considers various factors to determine price based on demand.

***Model 2: Demand-Based Price Function

A more advanced model where you:
â€¢ Construct a mathematical demand function using key features:

This markdown cell introduces Model 2, explaining that it's a demand-based model that uses multiple features to calculate demand.
"""

# Map traffic levels to numeric
traffic_map = {'low': 1, 'medium': 2, 'high': 3}
df['TrafficLevelNum'] = df['TrafficConditionNearby'].map(traffic_map)

# Assign numeric weights to vehicle types
vehicle_weights = {'bike': 0.5, 'car': 1.0, 'truck': 1.5}
df['VehicleWeight'] = df['VehicleType'].map(vehicle_weights)

"""This code cell prepares the data for Model 2 by mapping categorical features (`TrafficConditionNearby` and `VehicleType`) to numerical values.

* * *

This markdown cell defines the coefficients used in the demand function for Model 2.
"""

# Define coefficients
a, b, c, d, e = 0.5, 0.3, 0.2, 0.5, 0.7

# Raw demand calculation
df['DemandRaw'] = (
    a * df['OccupancyRate'] +
    b * df['QueueLength'] -
    c * df['TrafficLevelNum'] +
    d * df['IsSpecialDay'] +
    e * df['VehicleWeight']
)

"""This code cell calculates the raw demand based on the defined coefficients and the numerical features.

```
Normalize Demand & Set Price

This markdown cell indicates the next steps: normalizing the raw demand and setting the price based on the normalized demand.
"""

# Normalize demand to [0, 1]
dmin, dmax = df['DemandRaw'].min(), df['DemandRaw'].max()
df['DemandNorm'] = (df['DemandRaw'] - dmin) / (dmax - dmin)

# Define lambda for price sensitivity
lambda_val = 1.0

# Calculate demand-based price (bounded)
df['Price_Model2'] = 10 * (1 + lambda_val * df['DemandNorm'])
df['Price_Model2'] = df['Price_Model2'].clip(lower=5, upper=20)

"""This code cell normalizes the raw demand to a range between 0 and 1 and then calculates the `Price_Model2` based on the normalized demand and a price sensitivity factor (`lambda_val`). The price is also clipped to stay within a specified range (5 to 20).

***`Interactive Bokeh Plot for Model 2`

    plot Price_Model2 over time for the same parking lot

* * *

This markdown cell introduces the interactive Bokeh plot for Model 2.
"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool

# Enable Bokeh in notebook
output_notebook()

# Filter the same parking lot as before
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()

# Prepare timestamp string for hover
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Prepare data source
source = ColumnDataSource(sample_df)

# Create Bokeh plot
p2 = figure(x_axis_type="datetime", title=f"Model 2: Demand-Based Price Over Time for {sample_lot}",
           width=900, height=400, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Plot line and circles
p2.line(x='Timestamp', y='Price_Model2', source=source, line_width=2, color='green', legend_label='Price ($)')
p2.circle(x='Timestamp', y='Price_Model2', source=source, size=5, color='green', alpha=0.6)

# Hover tool
hover2 = p2.select(dict(type=HoverTool))
hover2.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model2{$0.00}"),
    ("Demand (normalized)", "@DemandNorm{0.00}")
]

# Axis labels and styling
p2.xaxis.axis_label = "Time"
p2.yaxis.axis_label = "Price ($)"
p2.legend.location = "top_left"
p2.grid.grid_line_alpha = 0.3

# Show the plot
show(p2)

"""This code generates an interactive Bokeh plot to visualize the `Price_Model2` over time for the sample parking lot, similar to the plot for Model 1, but with different styling and hover information.

## Model 3: Competitive Pricing Logic

This section introduces a more advanced model that incorporates competitive pricing based on nearby parking lots.

* * *

This markdown cell explains the concept of Model 3, which extends Model 2 by considering the prices and occupancy of nearby parking lots.

** Competitive Logic

If lot is full and nearby lots are cheaper â†’ suggest rerouting / reduce price

If nearby lots are expensive or full â†’ increase your price
**

This markdown cell details the competitive logic used in Model 3 to adjust prices and suggest rerouting.

```
 Haversine Function to Compute Proximity

This markdown cell introduces the Haversine function used to calculate the distance between parking lots.
"""

# Haversine distance in km
def haversine(lat1, lon1, lat2, lon2):
    R = 6371  # Earth radius (km)
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)

    a = np.sin(d_phi/2)**2 + np.cos(phi1)*np.cos(phi2)*np.sin(d_lambda/2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

"""This code cell defines the `haversine` function, which calculates the distance in kilometers between two points given their latitude and longitude.

```
Compute Nearby Lot Prices at Each Time

This markdown cell explains the next step: computing the prices of nearby parking lots at each timestamp.
"""

# Copy model 2 price
df['Price_Model3'] = df['Price_Model2']  # initialize from demand-based price
df['SuggestReroute'] = 0  # 1 if we suggest rerouting

# Group by time
for timestamp in df['Timestamp'].unique():
    snapshot = df[df['Timestamp'] == timestamp].copy()  # <--- Fix here

    for idx, row in snapshot.iterrows():
        lot_lat, lot_lon = row['Latitude'], row['Longitude']
        lot_price = row['Price_Model2']
        lot_occ = row['Occupancy']
        lot_cap = row['Capacity']

        snapshot['Distance'] = snapshot.apply(
            lambda r: haversine(lot_lat, lot_lon, r['Latitude'], r['Longitude']), axis=1)

        nearby = snapshot[(snapshot['SystemCodeNumber'] != row['SystemCodeNumber']) & (snapshot['Distance'] < 1)]

        if len(nearby) > 0:
            nearby_prices = nearby['Price_Model2']
            nearby_occ_rates = nearby['Occupancy'] / nearby['Capacity']

            avg_nearby_price = nearby_prices.mean()
            avg_nearby_occ = nearby_occ_rates.mean()

            # Pricing logic
            if (lot_occ / lot_cap) >= 0.9 and avg_nearby_price < lot_price:
                df.loc[idx, 'Price_Model3'] = max(5, lot_price - 2)
                df.loc[idx, 'SuggestReroute'] = 1
            elif avg_nearby_occ > 0.9 and avg_nearby_price > lot_price:
                df.loc[idx, 'Price_Model3'] = min(20, lot_price + 2)

"""This code cell implements the core logic of Model 3. It iterates through each timestamp, identifies nearby parking lots (within 1 km) for each lot, calculates the average price and occupancy of nearby lots, and adjusts the current lot's price (`Price_Model3`) based on the competitive logic. It also sets a `SuggestReroute` flag if rerouting is suggested.

```
 Bokeh Plot for Model 3 with Rerouting Highlights

Plot price over time

Using circle color for rerouting suggestion:

ðŸ”´ Red â†’ Reroute suggested

ðŸŸ¢ Green â†’ No reroute

This markdown cell describes the Bokeh plot for Model 3, which will visualize the price over time and highlight rerouting suggestions using different colored markers.
"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.transform import factor_cmap

output_notebook()

# Refresh sample lot
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Label rerouting as "Yes"/"No"
sample_df['Reroute'] = sample_df['SuggestReroute'].apply(lambda x: "Yes" if x == 1 else "No")

# Create data source
source = ColumnDataSource(sample_df)

# Color map: red if reroute suggested, green otherwise
reroute_colors = factor_cmap('Reroute',
                             palette=['green', 'red'],
                             factors=['No', 'Yes'])

# Create figure
p3 = figure(x_axis_type="datetime", title=f"Model 3: Competitive Price + Reroute Suggestion for {sample_lot}",
            width=950, height=450, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Line for base price evolution
p3.line(x='Timestamp', y='Price_Model3', source=source, line_width=2, color='black', legend_label='Price ($)')

# Colored circle markers for reroute suggestion
p3.circle(x='Timestamp', y='Price_Model3', source=source, size=8,
          fill_color=reroute_colors, line_color='black', alpha=0.8, legend_field='Reroute')

# Hover tool
hover = p3.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price", "@Price_Model3{$0.00}"),
    ("Suggest Reroute", "@Reroute"),
    ("Occupancy Rate", "@OccupancyRate{0.00}"),
]

# Styling
p3.xaxis.axis_label = "Time"
p3.yaxis.axis_label = "Price ($)"
p3.legend.location = "top_left"
p3.grid.grid_line_alpha = 0.3

# Show plot
show(p3)

"""This code generates an interactive Bokeh plot for Model 3, showing the price over time for the sample parking lot. It uses different colored circles to indicate when a reroute was suggested based on the competitive pricing logic.

## Model Comparison

This section compares the pricing results of Model 2 and Model 3.

```
 Comparison Plot: Model 2 vs Model 3 Pricing Over Time:

This markdown cell introduces the comparison plot between Model 2 and Model 3.
"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool

output_notebook()

# Filter same parking lot
sample_lot = df['SystemCodeNumber'].unique()[0]
sample_df = df[df['SystemCodeNumber'] == sample_lot].copy()
sample_df['Timestamp_str'] = sample_df['Timestamp'].dt.strftime("%Y-%m-%d %H:%M")

# Create source
source = ColumnDataSource(sample_df)

# Create plot
p_compare = figure(x_axis_type="datetime", title=f"Model 2 vs Model 3: Price Comparison for {sample_lot}",
                   width=950, height=450, tools="pan,wheel_zoom,box_zoom,reset,hover,save")

# Model 2 line (Demand-Based)
p_compare.line(x='Timestamp', y='Price_Model2', source=source, line_width=2,
               color='blue', legend_label='Model 2: Demand-Based')

# Model 3 line (Competitive)
p_compare.line(x='Timestamp', y='Price_Model3', source=source, line_width=2,
               color='red', legend_label='Model 3: Competitive')

# Add dots for better visibility
p_compare.circle(x='Timestamp', y='Price_Model2', source=source, size=5,
                 color='blue', alpha=0.6)
p_compare.circle(x='Timestamp', y='Price_Model3', source=source, size=5,
                 color='red', alpha=0.6)

# Hover tool
hover = p_compare.select(dict(type=HoverTool))
hover.tooltips = [
    ("Time", "@Timestamp_str"),
    ("Price M2", "@Price_Model2{$0.00}"),
    ("Price M3", "@Price_Model3{$0.00}"),
    ("Occupancy", "@Occupancy"),
    ("Reroute", "@SuggestReroute"),
]

# Styling
p_compare.xaxis.axis_label = "Time"
p_compare.yaxis.axis_label = "Price ($)"
p_compare.legend.location = "top_left"
p_compare.grid.grid_line_alpha = 0.3

# Show
show(p_compare)

"""This code generates a comparative interactive Bokeh plot showing the price over time for both Model 2 and Model 3 for the sample parking lot. This allows for a visual comparison of how the competitive logic in Model 3 influences the pricing compared to the purely demand-based Model 2.

```
Blue line: Demand-based pricing

Red line: Competitive-aware adjustments

Dips in red line when reroute is suggested

Red spikes where neighboring lots are full

This markdown cell provides a key to interpret the comparison plot, explaining what the blue and red lines represent and how the dips and spikes in the red line relate to rerouting suggestions and the occupancy of neighboring lots.

## Pathway Implementation (Attempt)

This section shows an attempt to implement the competitive pricing logic using the Pathway library for potential real-time data processing.
"""

!pip install pathway

"""This cell installs the `pathway` library."""

@pw.udf(return_type=float)
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)
    a = np.sin(d_phi / 2)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(d_lambda / 2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

"""This code cell defines the `haversine` function as a Pathway User Defined Function (`@pw.udf`) for use within the Pathway data processing pipeline."""

import pandas as pd
import pathway as pw
from pathway.internals.dtype import DATE_TIME_NAIVE
import numpy as np

# --- Step 1: Preprocess Data ----------------------------------
df['Timestamp'] = pd.to_datetime(
    df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
    format='%d-%m-%Y %H:%M:%S'
)
df['ID'] = df['ID'].astype(str)

# --- Step 2: Schema -------------------------------------------
class ParkingLot(pw.Schema):
    ID: str
    SystemCodeNumber: str
    Capacity: int
    Latitude: float
    Longitude: float
    Occupancy: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    Timestamp: DATE_TIME_NAIVE
    Price_Model2: float

# --- Step 3: ConnectorSubject ---------------------------------
class ParkingSubject(pw.io.python.ConnectorSubject):
    def __init__(self, df):
        super().__init__()
        self.df = df.sort_values('Timestamp')
    def run(self):
        for _, row in self.df.iterrows():
            self.next(
                ID=str(row['ID']),
                SystemCodeNumber=row['SystemCodeNumber'],
                Capacity=int(row['Capacity']),
                Latitude=float(row['Latitude']),
                Longitude=float(row['Longitude']),
                Occupancy=int(row['Occupancy']),
                VehicleType=row['VehicleType'],
                TrafficConditionNearby=row['TrafficConditionNearby'],
                QueueLength=int(row['QueueLength']),
                IsSpecialDay=int(row['IsSpecialDay']),
                Timestamp=row['Timestamp'],
                Price_Model2=float(row['Price_Model2'])
            )
        self.close()

#  Read stream --------------------------------------
stream = pw.io.python.read(ParkingSubject(df), schema=ParkingLot)

#  Rename columns in right stream before join -------
stream_reduced = stream.select(
    ID_R=stream.ID,
    Timestamp_R=stream.Timestamp,
    Latitude_R=stream.Latitude,
    Longitude_R=stream.Longitude,
    Capacity_R=stream.Capacity,
    Occupancy_R=stream.Occupancy,
    Price_Model2_R=stream.Price_Model2
)

#  Join streams -------------------------------------
joined = pw.join(stream, stream_reduced)

#  Haversine distance function ----------------------
@pw.udf(return_type=float)
def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    d_phi = np.radians(lat2 - lat1)
    d_lambda = np.radians(lon2 - lon1)
    a = np.sin(d_phi / 2)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(d_lambda / 2)**2
    return R * 2 * np.arcsin(np.sqrt(a))

#  Filter nearby competitors ------------------------
nearby = joined.filter(
    (joined["Timestamp"] == joined["Timestamp_R"]) &
    (haversine(
        joined["Latitude"], joined["Longitude"],
        joined["Latitude_R"], joined["Longitude_R"]
    ) < 1)
)


#Select into a real table
selected = nearby.select(
    ID=joined["ID"],
    Timestamp=joined["Timestamp"],
    SystemCodeNumber=joined["SystemCodeNumber"],
    Price_Model2=joined["Price_Model2"],
    Occupancy=joined["Occupancy"],
    Capacity=joined["Capacity"],
    Price_Model2_R=joined["Price_Model2_R"],
    Occupancy_R=joined["Occupancy_R"],
    Capacity_R=joined["Capacity_R"]
)

#
print("Columns:", selected.schema)


agg = selected.group_by("ID").reduce(
    ID=_.ID,
    Time=_.Timestamp,
    Lot=_.SystemCodeNumber,
    SelfPrice=_.Price_Model2,
    SelfOccRate=_.Occupancy / _.Capacity,
    AvgCompPrice=pw.reducers.mean(_.Price_Model2_R),
    AvgCompOccRate=pw.reducers.mean(_.Occupancy_R / _.Capacity_R)
)


#  Model 3 pricing logic ---------------------------
@pw.udf
def adjust_price(self_price, self_occ, comp_price, comp_occ):
    if self_occ >= 0.9 and comp_price < self_price:
        return max(5, self_price - 2), 1  # Suggest reroute
    elif comp_occ > 0.9 and comp_price > self_price:
        return min(20, self_price + 2), 0  # Increase price
    return self_price, 0  # No change

#  Final output ------------------------------------
final = agg.select(
    ID=agg.ID,
    Lot=agg.Lot,
    Time=agg.Time,
    Price_Model3_and_Reroute=adjust_price(
        agg.SelfPrice,
        agg.SelfOccRate,
        agg.AvgCompPrice,
        agg.AvgCompOccRate
    )
).select(
    ID=_.ID,
    Lot=_.Lot,
    Time=_.Time,
    Price_Model3=_.Price_Model3_and_Reroute[0],
    Reroute=_.Price_Model3_and_Reroute[1]
)

# Output to console -------------------------------
pw.io.jsonlines.write(final, "#")
pw.run()

"""This code cell attempts to implement the competitive pricing logic using Pathway. It defines a schema for the data, creates a data source from the pandas DataFrame, joins the data to compare each parking lot with nearby lots at the same timestamp, filters for nearby lots, aggregates competitor statistics, applies the pricing logic using a Pathway UDF, and attempts to output the final results.


"""

import pandas as pd
from bokeh.plotting import figure, show, output_file
from bokeh.models import ColumnDataSource, HoverTool

data = {
    'Time': pd.date_range(start='2025-07-07 08:00:00', periods=10, freq='5min'),
    'Price_Model3': [10, 11, 12, 10, 14, 13, 15, 10, 12, 11],
    'Reroute': [0, 0, 1, 0, 1, 0, 0, 1, 0, 0]
}


df_vis = pd.DataFrame(data)
df_vis['Color'] = df_vis['Reroute'].map({0: 'green', 1: 'red'})

source = ColumnDataSource(data=df_vis.to_dict(orient='list'))


p = figure(
    title="ðŸš— Model 3: Dynamic Parking Price & Reroute Suggestions",
    x_axis_type='datetime',
    x_axis_label='Time',
    y_axis_label='Price (â‚¹)',
    width=850,
    height=400,
    background_fill_color="#f9f9f9"
)


p.circle(
    x='Time', y='Price_Model3',
    size=10, color='Color',
    source=source,
    legend_field='Reroute'
)


hover = HoverTool(tooltips=[
    ("Time", "@Time{%F %T}"),
    ("Price", "@Price_Model3"),
    ("Reroute", "@Reroute")
], formatters={'@Time': 'datetime'})

p.add_tools(hover)

p.legend.title = "Reroute Suggested (1 = Yes)"
p.legend.location = "top_left"

output_file("model3_pricing.html", title="Model 3 Dynamic Pricing")
show(p)

"""This code cell generates a static Bokeh plot for Model 3 using a sample dataset (`df_vis`). It visualizes the price over time and uses colored circles to indicate rerouting suggestions. This plot is similar to the interactive one generated earlier but uses a simplified dataset for demonstration purposes and saves the output to an HTML file."""